<!DOCTYPE html>
<meta charset="utf-8">
<style>
.arc text {
  font: 10px sans-serif;
  text-anchor: middle;
}
.arc path {
  stroke: #fff;
}
</style>
<body>
  <button onClick="load('players/' + player.next())">Next Player</button>
  <button onClick="setPlayerScale(!playerScale); load('players/' + player.current())">League Scale</button>
<script src="https://d3js.org/d3.v4.js"></script>
<script>
const width = 960;
const height = 700;
const chartRadius = 600;
const arcLength = Math.PI / 6;

const polarToGrid = polar => {
  const x = Math.sin(polar.theta) * polar.r;
  const y = -Math.cos(polar.theta) * polar.r;

  return { x, y };
};

const players = [
  'aoki.csv',
  'frazier.csv',
  'mookie.csv',
  'yelich.csv',
  'schimpf.csv'
];

const player = (function() {
  let currentPlayer = 0;

  return {
    current: () => players[currentPlayer % players.length],

    next: () => {
      currentPlayer += 1;

      return players[currentPlayer % players.length];
    }
  };
}());

const color = d3.scaleLinear()
  .domain([0, 1.5])
  .range(['white', 'green']);

const pie = d3.pie()
    .startAngle(0)
    .endAngle(arcLength)
    .sort(null)
    .value(function(d) { return Math.max(5, d.sampleSize); });

const svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height)
  .append("g")
    .attr("transform", "translate("+ Math.min(0, width - chartRadius - 10) + "," + height / 2 + ")");

const typeVelocityAngle = (input) => Object.assign({
  velocity: +input.hit_speed,
  angle: +input.hit_angle
});

// last in wins
const distinctByKey = (dataArray, keyGenerator) => {
  const distinctMap = dataArray
    .reduce((agg, datum) => {
      agg[keyGenerator(datum)] = datum;
      return agg;
    }, {});

  return Object.keys(distinctMap).map(key => distinctMap[key]);
};

const angleLimits = performanceData => {
  return distinctByKey(performanceData, p => p.laMin + ':' + p.laMax)
    .map(p => Object.assign({
      laMin: p.laMin,
      laMax: p.laMax
    }))
    .sort((a, b) => a.laMin - b.laMin)
};

const velocityLimits = performanceData => {
  return distinctByKey(performanceData, p => p.evMin + ':' + p.evMax)
    .map(p => Object.assign({
      evMin: p.evMin,
      evMax: p.evMax
    }))
    .sort((a, b) => a.evMin - b.evMin)
};

const buildBucketer = (sortedLimits, getMin, getMax) => {
  const bucketer = new Array(sortedLimits.length);
  const first = sortedLimits[0];
  const last = sortedLimits[sortedLimits.length - 1];

  bucketer[0] = Object.assign({
    label: '< ' + getMax(first),
    fits: angle => angle < getMax(first),
    interpolate: () => 0.5
  }, first);

  bucketer[sortedLimits.length - 1] = Object.assign({
    label: '> ' + getMin(last),
    fits: angle => angle >= getMin(last),
    interpolate: () => 0.5
  }, last);

  for (let i = 1; i < sortedLimits.length - 1; i++) {
    const limit = sortedLimits[i];
    const min = getMin(limit);
    const max = getMax(limit);

    bucketer[i] = Object.assign({
      label: min + '-' + max,
      fits: input => input >= min && input < max,
      interpolate: input => (input - min) / (max - min)
    }, limit);
  }

  return bucketer;
}

const scaleAndDraw = function() {
  let leagueProdFetched = false;
  let leagueLaScale;
  let leagueEvScale;
  let laBucketer;
  let evBucketer;
  let leagueProduction;

  const drawScaled = (isPlayerScale, bipData) => {
    if (isPlayerScale) {
      draw(
        angleBucket(bipData, laBucketer),
        velocityBucket(bipData, evBucketer),
        leagueProduction,
        bipData
      );
    } else {
      draw(
        leagueLaScale,
        leagueEvScale,
        leagueProduction,
        bipData
      );
    }
  };

  return (isPlayerScale, bipData) => {
    if (leagueProdFetched) {
      drawScaled(isPlayerScale, bipData);
    } else {
      // fetch and parse league production data
      d3.json('./league/production.json', (err, production) => {
        leagueProdFetched = true;

        leagueProduction = production;

        laBucketer = buildBucketer(
          angleLimits(production),
          p => p.laMin,
          p => p.laMax);

        evBucketer = buildBucketer(
          velocityLimits(production),
          p => p.evMin,
          p => p.evMax);

        leagueLaScale = laBucketer.map(b => {
          const sampleSize = production
            .filter(lp => lp.laMin === b.laMin && lp.laMax === b.laMax)
            .reduce((agg, lp) => agg + lp.abs, 0);

          return Object.assign({}, b, {sampleSize});
        });

        leagueEvScale = evBucketer.map(b => {
          const sampleSize = production
            .filter(lp => lp.evMin === b.evMin && lp.evMax === b.evMax)
            .reduce((agg, lp) => agg + lp.abs, 0);

          return Object.assign({}, b, {sampleSize});
        });

        drawScaled(isPlayerScale, bipData);
      });
    }
  };
}();

// const atLeagueScale = function() {
//   let leagueLaScale;
//   let leagueEvScale;
//   let leagueProduction;
//
//   return callback => {
//     if (leagueLaScale && leagueEvScale) {
//       callback(leagueLaScale, leagueEvScale, leagueProduction);
//     } else {
//       d3.json('./league/production.json', (err, production) => {
//       leagueProduction = production
//
//       let laBucketer = buildBucketer(
//         angleLimits(production),
//         p => p.laMin,
//         p => p.laMax);
//
//       let evBucketer = buildBucketer(
//         velocityLimits(production),
//         p => p.evMin,
//         p => p.evMax);
//
//       leagueLaScale = laBucketer.map(b => {
//         let sampleSize = production
//           .filter(lp => lp.laMin === b.laMin && lp.laMax === b.laMax)
//           .reduce((agg, lp) => agg + lp.abs, 0);
//
//         return Object.assign({}, b, {sampleSize});
//       });
//
//       leagueEvScale = evBucketer.map(b => {
//         let sampleSize = production
//           .filter(lp => lp.evMin === b.evMin && lp.evMax === b.evMax)
//           .reduce((agg, lp) => agg + lp.abs, 0);
//
//         return Object.assign({}, b, {sampleSize});
//       });
//
//       callback(leagueLaScale, leagueEvScale, leagueProduction);
//     })
//   }
// }();

const lookupWoba = (production, params) => {
  const leagueResults = production.find(p =>
      p.evMin === params.evMin
      && p.evMax === params.evMax
      && p.laMin === params.laMin
      && p.laMax === params.laMax);

  return leagueResults ? leagueResults.wobaAvg : 0;
};

function initBuckets(bucketer) {
  return bucketer.map(b => Object.assign({}, b, {sampleSize:0}));
}

function angleBucket(velAngles, bucketer) {
  return bucketThings(velAngles, bucketer, va => va.angle);
}

function velocityBucket(velAngles, bucketer) {
  return bucketThings(velAngles, bucketer, va => va.velocity);
}

function bucketThings(velAngles, bucketer, getThing) {
  const buckets = initBuckets(bucketer);

  velAngles.map(getThing)
    .forEach(thing => bucketer.forEach((b, i) => {
      if (b.fits(thing)) {
        buckets[i].sampleSize += 1;
      }
    }));

  return buckets;
}

function calculateRadii(bucketed, accessor) {
  const ssAccessor = accessor ? accessor : d => d.sampleSizes;
  const sum = bucketed
    .map(ssAccessor)
    .reduce((agg, part) => agg + part, 0);
  const sections = [];

  console.log('sum');

  let runningSum = 0;

  bucketed.forEach(bucket => {
    const sampleSize = ssAccessor(bucket);

    const innerScaled = runningSum / sum;
    const outerScaled = (runningSum + sampleSize) / sum;

    const innerRadius = shiftArc(innerScaled) + 2;
    const outerRadius = shiftArc(outerScaled);

    sections.push(Object.assign({
      cornerRadius: 4,
      innerRadius,
      outerRadius
    }, bucket));

    runningSum += sampleSize;
  });

  return sections;
}

function shiftArc(scaled) {
  return scaled * (chartRadius * 0.7) + (chartRadius * 0.3);
}

function calculatePied(bucketed) {
  const pied = pie(bucketed);

  const {startAngle} = pied.find(p => p.data.label.startsWith('10') ? p : null);

  // rotate the chart so that ground balls (< 10 degrees) have a negative angle
  const piedShifted = pied.map(p => {
    p.startAngle = (p.startAngle - startAngle) * (-1) + (Math.PI / 2);
    p.endAngle = (p.endAngle - startAngle) * (-1) + (Math.PI / 2);

    return p;
  });

  return piedShifted;
}

load('./players/' + player.next());

function arcTween(radius) {
  return function factory(dParent) {
    const iStart = d3.interpolate(this._current.startAngle, dParent.startAngle);
    const iEnd = d3.interpolate(this._current.endAngle, dParent.endAngle);
    const iInner = d3.interpolate(this._current.innerRadius, radius.innerRadius);
    const iOuter = d3.interpolate(this._current.outerRadius, radius.outerRadius);

    // store the current for next interpolation
    this._current = Object.assign({}, dParent, radius);

    return function onTick(t) {
      return d3.arc()({
        innerRadius: iInner(t),
        outerRadius: iOuter(t),
        startAngle: iStart(t),
        endAngle: iEnd(t),
        padAngle: dParent.padAngle
      });
    };
  };
}

function draw(angles, velocities, leagueProduction, velAngles) {
  const radialSections = calculateRadii(velocities, d => Math.max(d.sampleSize, 5));
  const pied = calculatePied(angles);

  const plotted = mapToChart(
    velocities,
    radialSections.map(r => Object.assign({
      min: r.innerRadius,
      max: r.outerRadius
    })),
    angles,
    pied.map(p => Object.assign({
      min: p.startAngle,
      max: p.endAngle
    })),
    velAngles
  );

  const wedges = svg.selectAll(".wedge")
      .data(pied);

  // insert new wedges
  const newWedges = wedges.enter()
    .append("g")
      .attr("class", "wedge");

  // draw wedge sub-sections
  radialSections.forEach((radius, i) => {
    wedges.select(".arc" + i)
      .transition()
      .duration(400)
      .attrTween("d", arcTween(radius));

    newWedges.append("path")
      .attr("class", "arc" + i)
      .each(function(d) {
        d.innerRadius = radius.innerRadius;
        d.outerRadius = radius.outerRadius;

        d.woba = lookupWoba(leagueProduction, {
          evMin: radius.evMin,
          evMax: radius.evMax,
          laMin: d.data.laMin,
          laMax: d.data.laMax
        });

        // store current for second transition interpolation
        this._current = Object.assign({}, d, radius);
      })
      .attr("d", d3.arc())
      .style("fill", function(d) { return color(d.woba); });
  });

  // plot points
  const points = svg.selectAll(".bip")
    .data(plotted.map(polarToGrid));

  points.transition()
    .duration(400)
    .attr("cx", d => d.x)
    .attr("cy", d => d.y);

  points.enter()
    .append("circle")
    .attr("class", "bip")
    .attr("cx", d => d.x)
    .attr("cy", d => d.y)
    .attr("r", 2)
    .style("opacity", 0)
    .transition()
    .delay(300)
    .duration(600)
    .style("opacity", 1);

  points.exit().remove();

}

let playerScale = true;

function setPlayerScale(b) {
  playerScale = b;
}

function load (csvFile) {
  d3.csv(csvFile, typeVelocityAngle, function(error, velAngles) {
    scaleAndDraw(playerScale, velAngles);
    // if (!leagueScale) {
    //   getEvLaBounds((laBucketer, evBucketer, leagueProduction) => {
    //     const angles = angleBucket(velAngles, laBucketer);
    //     const velocities = velocityBucket(velAngles, evBucketer);
    //
    //     draw(angles, velocities, leagueProduction, velAngles);
    //   });
    // } else {
    //   atLeagueScale((angles, velocities, leagueProduction) =>
    //     draw(angles, velocities, leagueProduction, velAngles));
    // }
  });
}

function mapToChart(rBuckets, rMinMax, thetaBuckets, thetaMinMax, velAngles) {
  const rMapper = merge(rBuckets, rMinMax);
  const thetaMapper = merge(thetaBuckets, thetaMinMax);

  return velAngles.map(v => Object.assign({
    r: mapValue(rMapper, v.velocity),
    theta: mapValue(thetaMapper, v.angle)
  }));

  function mapValue(mapper, value) {
    const fit = mapper.find(m => m.fits(value) ? m : null);
    const scalar = fit.interpolate(value);

    return scalar * (fit.max - fit.min) + fit.min;
  }
}

function merge(arr1, arr2) {
  if (arr1.length !== arr2.length) {
    throw "wtf!";
  }

  return arr1.map((a, i) => Object.assign({}, a, arr2[i]));
}

</script>
</body>
