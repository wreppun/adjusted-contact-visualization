<!DOCTYPE html>
<meta charset="utf-8">
<style>
.arc text {
  font: 10px sans-serif;
  text-anchor: middle;
}
.arc path {
  stroke: #fff;
}
</style>
<body>
  <button onClick="load('players/' + nextPlayer())">next</button>
<script src="https://d3js.org/d3.v4.js"></script>
<script>
const width = 960;
const height = 700;
const chartRadius = 600;
const arcLength = Math.PI / 6;

const polarToGrid = polar => {
  const x = Math.sin(polar.theta) * polar.r;
  const y = -Math.cos(polar.theta) * polar.r;

  return { x, y };
};

const players = [
  'aoki.csv',
  'frazier.csv',
  'mookie.csv',
  'yelich.csv',
  'schimpf.csv'
];

const nextPlayer = (function() {
  let currentPlayer = 0;

  return function () {
    currentPlayer += 1;

    return players[currentPlayer % players.length];
  };
}());

const color = d3.scaleOrdinal()
    .range(["#98abc5", "#8a89a6", "#7b6888", "#6b486b", "#a05d56", "#d0743c", "#ff8c00"]);

const pie = d3.pie()
    .startAngle(0)
    .endAngle(arcLength)
    .sort(null)
    .value(function(d) { return Math.max(5, d.sampleSize); });

const svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height)
  .append("g")
    .attr("transform", "translate("+ Math.min(0, width - chartRadius - 10) + "," + height / 2 + ")");

const typeVelocityAngle = (input) => Object.assign({
  velocity: +input.hit_speed,
  angle: +input.hit_angle
});

const angleBucketer = [
  {
    label: '< -30',
    fits: angle => angle < -30,
    interpolate: () => 0.5
  },
  between(-30, -20),
  between(-20, -10),
  between(-10, 0),
  between(0, 10),
  between(10, 20),
  between(20, 30),
  between(30, 40),
  between(40, 50),
  {
    label: '> 50',
    fits: angle => angle >= 50,
    interpolate: () => 0.5
  }
];

const velocityBucketer = [
  {
    label: '< 60',
    fits: vel => vel < 60,
    interpolate: () => 0.5
  },
  between(60, 65),
  between(65, 70),
  between(70, 75),
  between(75, 80),
  between(80, 85),
  between(85, 90),
  between(90, 95),
  between(95, 100),
  between(100, 105),
  between(105, 110),
  {
    label: '> 110',
    fits: vel => vel >= 110,
    interpolate: () => 0.5
  }
];

function between(min, max) {
  return {
    label: parensIfNegative(min) + '-' + parensIfNegative(max),
    fits: input => input >= min && input < max,
    interpolate: val => (min - val) / (min - max)
  };
}

function parensIfNegative(num) {
  return num < 0 ? '(' + num + ')' : '' + num;
}

function initBuckets(bucketer) {
  return bucketer.map(b => Object.assign({}, b, {sampleSize:0}));
}

function angleBucket(velAngles) {
  return bucketThings(velAngles, angleBucketer, va => va.angle);
}

function velocityBucket(velAngles) {
  return bucketThings(velAngles, velocityBucketer, va => va.velocity);
}

function bucketThings(velAngles, bucketer, getThing) {
  const buckets = initBuckets(bucketer);

  velAngles.map(getThing)
    .forEach(thing => bucketer.forEach((b, i) => {
      if (b.fits(thing)) {
        buckets[i].sampleSize += 1;
      }
    }));

  return buckets;
}

function calculateRadii(bucketed, accessor) {
  const sampleSizes = bucketed.map(accessor ? accessor : d => d.sampleSizes);
  const sum = sampleSizes.reduce((agg, ss) => agg + ss, 0);
  const sections = [];

  let runningSum = 0;

  sampleSizes.forEach(sampleSize => {
    const innerScaled = runningSum / sum;
    const outerScaled = (runningSum + sampleSize) / sum;

    const innerRadius = shiftArc(innerScaled) + 2;
    const outerRadius = shiftArc(outerScaled);

    sections.push({
      cornerRadius: 4,
      innerRadius,
      outerRadius
    });

    runningSum += sampleSize;
  });

  return sections;
}

function shiftArc(scaled) {
  return scaled * (chartRadius * 0.7) + (chartRadius * 0.3);
}

function calculatePied(bucketed) {
  const pied = pie(bucketed);

  const {startAngle} = pied.find(p => p.data.label.startsWith('10') ? p : null);

  // rotate the chart so that ground balls (< 10 degrees) have a negative angle
  const piedShifted = pied.map(p => {
    p.startAngle = (p.startAngle - startAngle) * (-1) + (Math.PI / 2);
    p.endAngle = (p.endAngle - startAngle) * (-1) + (Math.PI / 2);

    return p;
  });

  return piedShifted;
}

load('./players/' + nextPlayer());

function arcTween(radius) {
  return function factory(dParent) {
    const iStart = d3.interpolate(this._current.startAngle, dParent.startAngle);
    const iEnd = d3.interpolate(this._current.endAngle, dParent.endAngle);
    const iInner = d3.interpolate(this._current.innerRadius, radius.innerRadius);
    const iOuter = d3.interpolate(this._current.outerRadius, radius.outerRadius);

    // store the current for next interpolation
    this._current = Object.assign({}, dParent, radius);

    return function onTick(t) {
      return d3.arc()({
        innerRadius: iInner(t),
        outerRadius: iOuter(t),
        startAngle: iStart(t),
        endAngle: iEnd(t),
        padAngle: dParent.padAngle
      });
    };
  };
}

function load (csvFile) {
  d3.csv(csvFile, typeVelocityAngle, function(error, velAngles) {
    const angles = angleBucket(velAngles);
    const velocities = velocityBucket(velAngles);
    const radialSections = calculateRadii(velocities, d => Math.max(d.sampleSize, 5));
    const pied = calculatePied(angles);

    const plotted = mapToChart(
      velocities,
      radialSections.map(r => Object.assign({
        min: r.innerRadius,
        max: r.outerRadius
      })),
      angles,
      pied.map(p => Object.assign({
        min: p.startAngle,
        max: p.endAngle
      })),
      velAngles
    );

    const wedges = svg.selectAll(".wedge")
        .data(pied);

    // insert new wedges
    const newWedges = wedges.enter()
      .append("g")
        .attr("class", "wedge");

    // draw wedge sub-sections
    radialSections.forEach((radius, i) => {
      wedges.select(".arc" + i)
        .transition()
        .duration(400)
        .attrTween("d", arcTween(radius));

      newWedges.append("path")
        .attr("class", "arc" + i)
        .each(function(d) {
          d.innerRadius = radius.innerRadius;
          d.outerRadius = radius.outerRadius;
          this._current = Object.assign({}, d, radius);
        })
        .attr("d", d3.arc())
        .style("fill", function(d) { return color(d.data.label); });
    });

    // plot points
    const points = svg.selectAll(".bip")
      .data(plotted.map(polarToGrid));

    points.transition()
      .duration(400)
      .attr("cx", d => d.x)
      .attr("cy", d => d.y);

    points.enter()
      .append("circle")
      .attr("class", "bip")
      .attr("cx", d => d.x)
      .attr("cy", d => d.y)
      .attr("r", 2)
      .style("opacity", 0)
      .transition()
      .delay(300)
      .duration(600)
      .style("opacity", 1);

    points.exit().remove();

  });

}

function interpolateViaBucket(buckets, values) {
  return values.map(v => buckets.find(b => b.fits(v) ? b : null).interpolate(v));
}

function mapToChart(rBuckets, rMinMax, thetaBuckets, thetaMinMax, velAngles) {
  if (rBuckets.length !== rMinMax.length) {
    throw "wtf";
  }

  if (thetaBuckets.length !== thetaMinMax.length) {
    throw "wtf!";
  }

  const rMapper = rBuckets.map(
    (b, i) => Object.assign({}, b, rMinMax[i])
  );

  const thetaMapper = thetaBuckets.map(
    (b, i) => Object.assign({}, b, thetaMinMax[i])
  );

  return velAngles.map(v => Object.assign({
    r: mapValue(rMapper, v.velocity),
    theta: mapValue(thetaMapper, v.angle)
  }));

  function mapValue(mapper, value) {
    const fit = mapper.find(m => m.fits(value) ? m : null);
    const scalar = fit.interpolate(value);

    return scalar * (fit.max - fit.min) + fit.min;
  }
}


function typeSampleSize(d) {
  d.sampleSize = +d.sampleSize;
  return d;
}

</script>
</body>
